# Правила разработки

## CSS Импорты

**pattern**: `@import.*\.css`
**description**: При импорте CSS файлов в Tailwind CSS всегда используй относительный путь с `./` для файлов в той же директории
**examples**: 
  - ❌ Неправильно: `@import "cta.css" layer(components);`
  - ✅ Правильно: `@import "./cta.css" layer(components);`
**exceptions**: Импорты из node_modules могут использоваться без `./`

## Footer Case & Review AJAX Архитектура

**pattern**: `footer-(case|review).*`
**description**: Footer case и review используют одинаковую архитектуру динамической загрузки через AJAX с fade анимацией. Поддерживают множественные экземпляры на странице
**structure**:
  - Контейнер `.footer-case-container` / `.footer-review-container` с overflow-hidden
  - Кнопка `.footer-case__refresh` / `.footer-review__refresh` с атрибутом `data-refresh-url`
  - Элементы `.footer-case` / `.footer-review` абсолютно позиционированы с `transition-all`
  - Состояния управляются через `data-active` атрибут с классами `data-[active=true]:opacity-100 data-[active=true]:pointer-events-auto`
  - Загрузка: disabled кнопка + animate-spin иконка, timeout 10 секунд
  - Каждая кнопка инициализируется отдельно через `.each()` с локальным состоянием
**ajax**:
  - При наличии `data-id` у текущего элемента, ID передается в параметре `?id=` или `&id=`
  - Сервер возвращает готовый HTML элемента без позиционирования
  - JavaScript автоматически устанавливает `data-active="false"`
  - Последовательность: `data-active="false"` старые → `data-active="true"` новый → удалить старые
**examples**:
  - ✅ Правильно: Управление состояниями через `data-active` атрибут
  - ✅ Правильно: Кейс и отзыв как кликабельные ссылки с hover эффектами
  - ✅ Правильно: Кнопка обновления в углу контейнера
  - ✅ Правильно: Инициализация через `$('.footer-case__refresh').each()`
  - ❌ Неправильно: Прямое управление классами opacity/pointer-events
  - ❌ Неправильно: Глобальные селекторы без поддержки множественных экземпляров
**exceptions**: При ошибке AJAX console.error, кнопка разблокируется

## Адаптивные контейнеры с переключением

**pattern**: `(contact|switcher).*container`
**description**: Для контейнеров с переключаемым содержимым используй разные стратегии позиционирования в зависимости от разрешения экрана
**structure**:
  - Мобильные разрешения (до lg): используй `display: none/block` для автоматической подстройки высоты контейнера
  - Десктопные разрешения (lg+): используй `absolute` позиционирование с `opacity`/`pointer-events` для фиксированной высоты
  - Классы переключения: `max-lg:hidden max-lg:data-[active=true]:block lg:absolute lg:inset-0`
  - Убирай фиксированную высоту контейнера для мобильных разрешений
**examples**:
  - ✅ Правильно: `max-lg:hidden max-lg:data-[active=true]:block lg:transition-opacity lg:opacity-0`
  - ✅ Правильно: Убрать `h-[954px] md:h-[853px]` из контейнера, оставить только `lg:h-[676px]`
  - ❌ Неправильно: Использовать одинаковое позиционирование для всех разрешений
**exceptions**: Когда дизайн требует фиксированной высоты на всех разрешениях 

## JavaScript компоненты с множественными экземплярами

**pattern**: `\.(b-[\w-]+)\.js`
**description**: Блоки JavaScript должны поддерживать работу с несколькими экземплярами на одной странице через инициализацию каждого элемента отдельно
**structure**:
  - Используй `.each()` для инициализации каждого экземпляра компонента отдельно
  - Состояние (isLoading, текущие элементы) должно быть локальным для каждого экземпляра
  - Найди родительский контейнер через `.closest()` для ограничения области действия
  - Избегай глобальных селекторов, работай только с элементами внутри текущего контейнера
**examples**:
  - ✅ Правильно: `$('.component__button').each(function() { const $button = $(this); const $container = $button.closest('.component-container'); })`
  - ✅ Правильно: Локальные переменные состояния внутри each()
  - ❌ Неправильно: `const $container = $('.component-container');` (глобальный селектор)
  - ❌ Неправильно: Глобальные переменные состояния вне each()
**exceptions**: Когда компонент гарантированно единственный на странице

## Header интерактивность с data-атрибутами

**pattern**: `header.*data-open`
**description**: Для управления интерактивными секциями header используй data-атрибуты в качестве единственного источника состояния
**structure**:
  - JavaScript управляет только переключением `data-open="true/false"` у родительского контейнера `.header`
  - CSS стили реагируют на data-атрибут через селекторы `[data-open="true"]`
  - Поддерживай локальное состояние для каждого header экземпляра через `.each()`
  - Используй таймеры для задержек и правильно их очищай через `clearTimeout()`
  - Разделяй ручное (клик) и автоматическое (hover) управление состоянием
  - Используй состояние `isOpening` для отслеживания процесса автоматического открытия (500ms)
  - Клик на toggle во время `isOpening` должен подтверждать ручное открытие вместо закрытия
  - Добавляй задержку 600ms перед автоматическим закрытием при уходе курсора (для автоматически открытых меню)
  - Обязательно добавляй обработчик клика на `.header__overlay` для закрытия меню
  - Используй 3D анимацию гаражной двери для header__extra (rotateX + transform-origin: top + perspective)
  - При открытии меню добавляй `overflow-hidden` к body, при закрытии убирай для блокировки прокрутки
  - Перед блокировкой прокрутки вычисляй ширину скроллбара и добавляй `padding-right` к body для компенсации
**examples**:
  - ✅ Правильно: `$header.attr('data-open', 'true')` для управления состоянием
  - ✅ Правильно: `.header[data-open="true"] .header__extra { transform: rotateX(0deg); opacity: 1; }` в CSS (анимация гаражной двери)
  - ✅ Правильно: Локальные переменные `isManuallyOpened`, `hoverTimeout`, `closeTimeout`, `isOpening` внутри `.each()`
  - ✅ Правильно: Проверка `if (isOpening && isOpen) { isManuallyOpened = true; return; }` для подтверждения ручного открытия
  - ❌ Неправильно: Прямое управление CSS классами `show/hide`
  - ❌ Неправильно: Глобальные таймеры или состояние
**exceptions**: Когда требуется более сложная анимация с несколькими состояниями